
“三次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。

三次握手：
	第一次握手：
		client将标志位SYN置为1，随机产生序列号seq=x，并将数据包发送给server，client进入SYN-SENT状态
		**************************TCP规定SYN=1时不能鞋带数据，x为随机产生**************************
	第二次握手：
		server收到数据包后由SYN=1得知client请求建立连接，server将SYN和ACK都置为1，ack=x+1，随机产生序列号seq=y，
		并将数据包发送给client以确认连接请求，server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量
		**************************此时成为半连接状态**************************
	第三次握手：
		client收到确认后，检查ack是否为x+1，ACK是否置为1，如果正确则将ACK置为1，ack=y+1，
		并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给server，
		server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，
		client和server进入ESTABLISHED状态，完成三次握手
		**************************第三次握手可以携带数据**************************
		
		
为什么A还要发送一次确认呢？可以二次握手吗？
	主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。
	如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。
	后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，
	A共发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，
	但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B，
	此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，
	不采用三次握手，只要B发出确认，就建立新的连接了，
	此时A并没有请求建立连接，因此不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。

Server端易受到SYN攻击？
	服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，
	SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，
	由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，
	导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。
	
	检测：
		当server上有大量半连接状态且源IP地址是随机的，则可以断定遭到了SYN攻击
	
	防范SYN攻击措施：
		1、增加syn连接*****未解决根本*****
		2、SYN+ACK重试次数：
			降低主机的等待时间使主机尽快的释放半连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。
		3、SYN+Cookie技术：
			server收到syn后不立即分配资源，而是根据syn计算出一个cookie，连同第二次握手回复给client，在client收到ACK时带上cookie值，server验证cookie合法性之后再分配资源

listen backlog:
服务器监听时，在每次处理一个客户端的连接时是需要一定时间的，这个时间非常的短(也许只有1ms或者还不到)，但这个时间还是存在的。而这个backlog存在的意义就是：在这段时间里面除了第一个连接请求是正在进行处理以外，其他的连接请求都在请求队列中等待，而如果超过了队列的最大等待个数时，其他的请求将被忽略或者将不会被处理。这个backlog 的值就是影响这个队列的大小的。
/proc/sys/net/core/somaxconn跟listen参数的最小值作为backlog的值。

在FressBSD中backlog就是描述状态为SYN_REVD和ESTABLISHED的所有连接最大数量。
而Linux系统中，则使用两个队列syn queue, accept queue分别存储状态为SYN_REVD和ESTABLISHED的连接，并且在linux2.2及以后，backlog表示accept queue的大小，而syn queue大小由 /proc/sys/net/ipv4/tcp_max_syn_backlog配置。


连接队列：
	
半连接队列满了
条目所标识的连接在服务器处于 Syn_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入 ESTABLISHED 状态。
目前，Linux 下默认会进行 5 次重发 SYN-ACK 包，重试的间隔时间从 1s 开始，下次的重试间隔时间是前一次的双倍，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s, 总共 31s，称为指数退避。
第 5 次发出后还要等 32s 才知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s + 8s + 16s + 32s = 63s，TCP 才会断开这个连接。
由于，SYN 超时需要 63 秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的 SYN 包给 Server(俗称 SYN Flood 攻击)，用于耗尽 Server 的 SYN 队列。

全连接队列满了
当第三次握手时，当 Server 接收到 ACK 包之后，会进入一个新的叫 Accept 的队列。
当 Accept 队列满了之后，即使 Client 继续向 Server 发送 ACK 的包，也会不被响应。
此时 ListenOverflows+1，同时 Server 通过 tcp_abort_on_overflow 来决定如何返回，0 表示直接丢弃该 ACK，1 表示发送 RST 通知 Client。
相应的，Client 则会分别返回 read timeout 或者 connection reset by peer。
另外，tcp_abort_on_overflow 是 0 的话，Server 过一段时间再次发送 SYN+ACK 给 Client（也就是重新走握手的第二步），如果 Client 超时等待比较短，就很容易异常了。
而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 Accept 队列有空闲的时候最终完成连接。
若 Accept 队列始终满员，则最终客户端收到 RST 包（此时服务端发送 SYN+ACK 的次数超出了 tcp_synack_retries）。















